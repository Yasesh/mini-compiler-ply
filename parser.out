Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> decl_list stmt_list
Rule 2     decl_list -> <empty>
Rule 3     decl_list -> decl decl_list
Rule 4     decl -> INT id_list SEMI
Rule 5     id_list -> ID
Rule 6     id_list -> ID COMMA id_list
Rule 7     stmt_list -> <empty>
Rule 8     stmt_list -> stmt stmt_list
Rule 9     stmt -> ID ASSIGN expr SEMI
Rule 10    stmt -> IF LPAREN cond RPAREN stmt
Rule 11    stmt -> IF LPAREN cond RPAREN stmt ELSE stmt
Rule 12    stmt -> WHILE LPAREN cond RPAREN stmt
Rule 13    stmt -> LBRACE stmt_list RBRACE
Rule 14    cond -> expr relop expr
Rule 15    relop -> GT
Rule 16    relop -> LT
Rule 17    relop -> GE
Rule 18    relop -> LE
Rule 19    relop -> EQ
Rule 20    relop -> NE
Rule 21    expr -> expr PLUS term
Rule 22    expr -> expr MINUS term
Rule 23    expr -> term
Rule 24    term -> term TIMES factor
Rule 25    term -> term DIVIDE factor
Rule 26    term -> factor
Rule 27    factor -> NUMBER
Rule 28    factor -> ID
Rule 29    factor -> LPAREN expr RPAREN

Terminals, with rules where they appear

ASSIGN               : 9
COMMA                : 6
DIVIDE               : 25
ELSE                 : 11
EQ                   : 19
GE                   : 17
GT                   : 15
ID                   : 5 6 9 28
IF                   : 10 11
INT                  : 4
LBRACE               : 13
LE                   : 18
LPAREN               : 10 11 12 29
LT                   : 16
MINUS                : 22
NE                   : 20
NUMBER               : 27
PLUS                 : 21
RBRACE               : 13
RPAREN               : 10 11 12 29
SEMI                 : 4 9
TIMES                : 24
WHILE                : 12
error                : 

Nonterminals, with rules where they appear

cond                 : 10 11 12
decl                 : 3
decl_list            : 1 3
expr                 : 9 14 14 21 22 29
factor               : 24 25 26
id_list              : 4 6
program              : 0
relop                : 14
stmt                 : 8 10 11 11 12
stmt_list            : 1 8 13
term                 : 21 22 23 24 25

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . decl_list stmt_list
    (2) decl_list -> .
    (3) decl_list -> . decl decl_list
    (4) decl -> . INT id_list SEMI

    ID              reduce using rule 2 (decl_list -> .)
    IF              reduce using rule 2 (decl_list -> .)
    WHILE           reduce using rule 2 (decl_list -> .)
    LBRACE          reduce using rule 2 (decl_list -> .)
    $end            reduce using rule 2 (decl_list -> .)
    INT             shift and go to state 4

    program                        shift and go to state 1
    decl_list                      shift and go to state 2
    decl                           shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (1) program -> decl_list . stmt_list
    (7) stmt_list -> .
    (8) stmt_list -> . stmt stmt_list
    (9) stmt -> . ID ASSIGN expr SEMI
    (10) stmt -> . IF LPAREN cond RPAREN stmt
    (11) stmt -> . IF LPAREN cond RPAREN stmt ELSE stmt
    (12) stmt -> . WHILE LPAREN cond RPAREN stmt
    (13) stmt -> . LBRACE stmt_list RBRACE

    $end            reduce using rule 7 (stmt_list -> .)
    ID              shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 9
    LBRACE          shift and go to state 10

    stmt_list                      shift and go to state 5
    stmt                           shift and go to state 6

state 3

    (3) decl_list -> decl . decl_list
    (2) decl_list -> .
    (3) decl_list -> . decl decl_list
    (4) decl -> . INT id_list SEMI

    ID              reduce using rule 2 (decl_list -> .)
    IF              reduce using rule 2 (decl_list -> .)
    WHILE           reduce using rule 2 (decl_list -> .)
    LBRACE          reduce using rule 2 (decl_list -> .)
    $end            reduce using rule 2 (decl_list -> .)
    INT             shift and go to state 4

    decl                           shift and go to state 3
    decl_list                      shift and go to state 11

state 4

    (4) decl -> INT . id_list SEMI
    (5) id_list -> . ID
    (6) id_list -> . ID COMMA id_list

    ID              shift and go to state 13

    id_list                        shift and go to state 12

state 5

    (1) program -> decl_list stmt_list .

    $end            reduce using rule 1 (program -> decl_list stmt_list .)


state 6

    (8) stmt_list -> stmt . stmt_list
    (7) stmt_list -> .
    (8) stmt_list -> . stmt stmt_list
    (9) stmt -> . ID ASSIGN expr SEMI
    (10) stmt -> . IF LPAREN cond RPAREN stmt
    (11) stmt -> . IF LPAREN cond RPAREN stmt ELSE stmt
    (12) stmt -> . WHILE LPAREN cond RPAREN stmt
    (13) stmt -> . LBRACE stmt_list RBRACE

    $end            reduce using rule 7 (stmt_list -> .)
    RBRACE          reduce using rule 7 (stmt_list -> .)
    ID              shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 9
    LBRACE          shift and go to state 10

    stmt                           shift and go to state 6
    stmt_list                      shift and go to state 14

state 7

    (9) stmt -> ID . ASSIGN expr SEMI

    ASSIGN          shift and go to state 15


state 8

    (10) stmt -> IF . LPAREN cond RPAREN stmt
    (11) stmt -> IF . LPAREN cond RPAREN stmt ELSE stmt

    LPAREN          shift and go to state 16


state 9

    (12) stmt -> WHILE . LPAREN cond RPAREN stmt

    LPAREN          shift and go to state 17


state 10

    (13) stmt -> LBRACE . stmt_list RBRACE
    (7) stmt_list -> .
    (8) stmt_list -> . stmt stmt_list
    (9) stmt -> . ID ASSIGN expr SEMI
    (10) stmt -> . IF LPAREN cond RPAREN stmt
    (11) stmt -> . IF LPAREN cond RPAREN stmt ELSE stmt
    (12) stmt -> . WHILE LPAREN cond RPAREN stmt
    (13) stmt -> . LBRACE stmt_list RBRACE

    RBRACE          reduce using rule 7 (stmt_list -> .)
    ID              shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 9
    LBRACE          shift and go to state 10

    stmt_list                      shift and go to state 18
    stmt                           shift and go to state 6

state 11

    (3) decl_list -> decl decl_list .

    ID              reduce using rule 3 (decl_list -> decl decl_list .)
    IF              reduce using rule 3 (decl_list -> decl decl_list .)
    WHILE           reduce using rule 3 (decl_list -> decl decl_list .)
    LBRACE          reduce using rule 3 (decl_list -> decl decl_list .)
    $end            reduce using rule 3 (decl_list -> decl decl_list .)


state 12

    (4) decl -> INT id_list . SEMI

    SEMI            shift and go to state 19


state 13

    (5) id_list -> ID .
    (6) id_list -> ID . COMMA id_list

    SEMI            reduce using rule 5 (id_list -> ID .)
    COMMA           shift and go to state 20


state 14

    (8) stmt_list -> stmt stmt_list .

    $end            reduce using rule 8 (stmt_list -> stmt stmt_list .)
    RBRACE          reduce using rule 8 (stmt_list -> stmt stmt_list .)


state 15

    (9) stmt -> ID ASSIGN . expr SEMI
    (21) expr -> . expr PLUS term
    (22) expr -> . expr MINUS term
    (23) expr -> . term
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . factor
    (27) factor -> . NUMBER
    (28) factor -> . ID
    (29) factor -> . LPAREN expr RPAREN

    NUMBER          shift and go to state 25
    ID              shift and go to state 21
    LPAREN          shift and go to state 26

    expr                           shift and go to state 22
    term                           shift and go to state 23
    factor                         shift and go to state 24

state 16

    (10) stmt -> IF LPAREN . cond RPAREN stmt
    (11) stmt -> IF LPAREN . cond RPAREN stmt ELSE stmt
    (14) cond -> . expr relop expr
    (21) expr -> . expr PLUS term
    (22) expr -> . expr MINUS term
    (23) expr -> . term
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . factor
    (27) factor -> . NUMBER
    (28) factor -> . ID
    (29) factor -> . LPAREN expr RPAREN

    NUMBER          shift and go to state 25
    ID              shift and go to state 21
    LPAREN          shift and go to state 26

    cond                           shift and go to state 27
    expr                           shift and go to state 28
    term                           shift and go to state 23
    factor                         shift and go to state 24

state 17

    (12) stmt -> WHILE LPAREN . cond RPAREN stmt
    (14) cond -> . expr relop expr
    (21) expr -> . expr PLUS term
    (22) expr -> . expr MINUS term
    (23) expr -> . term
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . factor
    (27) factor -> . NUMBER
    (28) factor -> . ID
    (29) factor -> . LPAREN expr RPAREN

    NUMBER          shift and go to state 25
    ID              shift and go to state 21
    LPAREN          shift and go to state 26

    cond                           shift and go to state 29
    expr                           shift and go to state 28
    term                           shift and go to state 23
    factor                         shift and go to state 24

state 18

    (13) stmt -> LBRACE stmt_list . RBRACE

    RBRACE          shift and go to state 30


state 19

    (4) decl -> INT id_list SEMI .

    INT             reduce using rule 4 (decl -> INT id_list SEMI .)
    ID              reduce using rule 4 (decl -> INT id_list SEMI .)
    IF              reduce using rule 4 (decl -> INT id_list SEMI .)
    WHILE           reduce using rule 4 (decl -> INT id_list SEMI .)
    LBRACE          reduce using rule 4 (decl -> INT id_list SEMI .)
    $end            reduce using rule 4 (decl -> INT id_list SEMI .)


state 20

    (6) id_list -> ID COMMA . id_list
    (5) id_list -> . ID
    (6) id_list -> . ID COMMA id_list

    ID              shift and go to state 13

    id_list                        shift and go to state 31

state 21

    (28) factor -> ID .

    TIMES           reduce using rule 28 (factor -> ID .)
    DIVIDE          reduce using rule 28 (factor -> ID .)
    SEMI            reduce using rule 28 (factor -> ID .)
    PLUS            reduce using rule 28 (factor -> ID .)
    MINUS           reduce using rule 28 (factor -> ID .)
    GT              reduce using rule 28 (factor -> ID .)
    LT              reduce using rule 28 (factor -> ID .)
    GE              reduce using rule 28 (factor -> ID .)
    LE              reduce using rule 28 (factor -> ID .)
    EQ              reduce using rule 28 (factor -> ID .)
    NE              reduce using rule 28 (factor -> ID .)
    RPAREN          reduce using rule 28 (factor -> ID .)


state 22

    (9) stmt -> ID ASSIGN expr . SEMI
    (21) expr -> expr . PLUS term
    (22) expr -> expr . MINUS term

    SEMI            shift and go to state 32
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34


state 23

    (23) expr -> term .
    (24) term -> term . TIMES factor
    (25) term -> term . DIVIDE factor

    SEMI            reduce using rule 23 (expr -> term .)
    PLUS            reduce using rule 23 (expr -> term .)
    MINUS           reduce using rule 23 (expr -> term .)
    GT              reduce using rule 23 (expr -> term .)
    LT              reduce using rule 23 (expr -> term .)
    GE              reduce using rule 23 (expr -> term .)
    LE              reduce using rule 23 (expr -> term .)
    EQ              reduce using rule 23 (expr -> term .)
    NE              reduce using rule 23 (expr -> term .)
    RPAREN          reduce using rule 23 (expr -> term .)
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36


state 24

    (26) term -> factor .

    TIMES           reduce using rule 26 (term -> factor .)
    DIVIDE          reduce using rule 26 (term -> factor .)
    SEMI            reduce using rule 26 (term -> factor .)
    PLUS            reduce using rule 26 (term -> factor .)
    MINUS           reduce using rule 26 (term -> factor .)
    GT              reduce using rule 26 (term -> factor .)
    LT              reduce using rule 26 (term -> factor .)
    GE              reduce using rule 26 (term -> factor .)
    LE              reduce using rule 26 (term -> factor .)
    EQ              reduce using rule 26 (term -> factor .)
    NE              reduce using rule 26 (term -> factor .)
    RPAREN          reduce using rule 26 (term -> factor .)


state 25

    (27) factor -> NUMBER .

    TIMES           reduce using rule 27 (factor -> NUMBER .)
    DIVIDE          reduce using rule 27 (factor -> NUMBER .)
    SEMI            reduce using rule 27 (factor -> NUMBER .)
    PLUS            reduce using rule 27 (factor -> NUMBER .)
    MINUS           reduce using rule 27 (factor -> NUMBER .)
    GT              reduce using rule 27 (factor -> NUMBER .)
    LT              reduce using rule 27 (factor -> NUMBER .)
    GE              reduce using rule 27 (factor -> NUMBER .)
    LE              reduce using rule 27 (factor -> NUMBER .)
    EQ              reduce using rule 27 (factor -> NUMBER .)
    NE              reduce using rule 27 (factor -> NUMBER .)
    RPAREN          reduce using rule 27 (factor -> NUMBER .)


state 26

    (29) factor -> LPAREN . expr RPAREN
    (21) expr -> . expr PLUS term
    (22) expr -> . expr MINUS term
    (23) expr -> . term
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . factor
    (27) factor -> . NUMBER
    (28) factor -> . ID
    (29) factor -> . LPAREN expr RPAREN

    NUMBER          shift and go to state 25
    ID              shift and go to state 21
    LPAREN          shift and go to state 26

    expr                           shift and go to state 37
    term                           shift and go to state 23
    factor                         shift and go to state 24

state 27

    (10) stmt -> IF LPAREN cond . RPAREN stmt
    (11) stmt -> IF LPAREN cond . RPAREN stmt ELSE stmt

    RPAREN          shift and go to state 38


state 28

    (14) cond -> expr . relop expr
    (21) expr -> expr . PLUS term
    (22) expr -> expr . MINUS term
    (15) relop -> . GT
    (16) relop -> . LT
    (17) relop -> . GE
    (18) relop -> . LE
    (19) relop -> . EQ
    (20) relop -> . NE

    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    GT              shift and go to state 40
    LT              shift and go to state 41
    GE              shift and go to state 42
    LE              shift and go to state 43
    EQ              shift and go to state 44
    NE              shift and go to state 45

    relop                          shift and go to state 39

state 29

    (12) stmt -> WHILE LPAREN cond . RPAREN stmt

    RPAREN          shift and go to state 46


state 30

    (13) stmt -> LBRACE stmt_list RBRACE .

    ID              reduce using rule 13 (stmt -> LBRACE stmt_list RBRACE .)
    IF              reduce using rule 13 (stmt -> LBRACE stmt_list RBRACE .)
    WHILE           reduce using rule 13 (stmt -> LBRACE stmt_list RBRACE .)
    LBRACE          reduce using rule 13 (stmt -> LBRACE stmt_list RBRACE .)
    $end            reduce using rule 13 (stmt -> LBRACE stmt_list RBRACE .)
    RBRACE          reduce using rule 13 (stmt -> LBRACE stmt_list RBRACE .)
    ELSE            reduce using rule 13 (stmt -> LBRACE stmt_list RBRACE .)


state 31

    (6) id_list -> ID COMMA id_list .

    SEMI            reduce using rule 6 (id_list -> ID COMMA id_list .)


state 32

    (9) stmt -> ID ASSIGN expr SEMI .

    ID              reduce using rule 9 (stmt -> ID ASSIGN expr SEMI .)
    IF              reduce using rule 9 (stmt -> ID ASSIGN expr SEMI .)
    WHILE           reduce using rule 9 (stmt -> ID ASSIGN expr SEMI .)
    LBRACE          reduce using rule 9 (stmt -> ID ASSIGN expr SEMI .)
    $end            reduce using rule 9 (stmt -> ID ASSIGN expr SEMI .)
    RBRACE          reduce using rule 9 (stmt -> ID ASSIGN expr SEMI .)
    ELSE            reduce using rule 9 (stmt -> ID ASSIGN expr SEMI .)


state 33

    (21) expr -> expr PLUS . term
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . factor
    (27) factor -> . NUMBER
    (28) factor -> . ID
    (29) factor -> . LPAREN expr RPAREN

    NUMBER          shift and go to state 25
    ID              shift and go to state 21
    LPAREN          shift and go to state 26

    term                           shift and go to state 47
    factor                         shift and go to state 24

state 34

    (22) expr -> expr MINUS . term
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . factor
    (27) factor -> . NUMBER
    (28) factor -> . ID
    (29) factor -> . LPAREN expr RPAREN

    NUMBER          shift and go to state 25
    ID              shift and go to state 21
    LPAREN          shift and go to state 26

    term                           shift and go to state 48
    factor                         shift and go to state 24

state 35

    (24) term -> term TIMES . factor
    (27) factor -> . NUMBER
    (28) factor -> . ID
    (29) factor -> . LPAREN expr RPAREN

    NUMBER          shift and go to state 25
    ID              shift and go to state 21
    LPAREN          shift and go to state 26

    factor                         shift and go to state 49

state 36

    (25) term -> term DIVIDE . factor
    (27) factor -> . NUMBER
    (28) factor -> . ID
    (29) factor -> . LPAREN expr RPAREN

    NUMBER          shift and go to state 25
    ID              shift and go to state 21
    LPAREN          shift and go to state 26

    factor                         shift and go to state 50

state 37

    (29) factor -> LPAREN expr . RPAREN
    (21) expr -> expr . PLUS term
    (22) expr -> expr . MINUS term

    RPAREN          shift and go to state 51
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34


state 38

    (10) stmt -> IF LPAREN cond RPAREN . stmt
    (11) stmt -> IF LPAREN cond RPAREN . stmt ELSE stmt
    (9) stmt -> . ID ASSIGN expr SEMI
    (10) stmt -> . IF LPAREN cond RPAREN stmt
    (11) stmt -> . IF LPAREN cond RPAREN stmt ELSE stmt
    (12) stmt -> . WHILE LPAREN cond RPAREN stmt
    (13) stmt -> . LBRACE stmt_list RBRACE

    ID              shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 9
    LBRACE          shift and go to state 10

    stmt                           shift and go to state 52

state 39

    (14) cond -> expr relop . expr
    (21) expr -> . expr PLUS term
    (22) expr -> . expr MINUS term
    (23) expr -> . term
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . factor
    (27) factor -> . NUMBER
    (28) factor -> . ID
    (29) factor -> . LPAREN expr RPAREN

    NUMBER          shift and go to state 25
    ID              shift and go to state 21
    LPAREN          shift and go to state 26

    expr                           shift and go to state 53
    term                           shift and go to state 23
    factor                         shift and go to state 24

state 40

    (15) relop -> GT .

    NUMBER          reduce using rule 15 (relop -> GT .)
    ID              reduce using rule 15 (relop -> GT .)
    LPAREN          reduce using rule 15 (relop -> GT .)


state 41

    (16) relop -> LT .

    NUMBER          reduce using rule 16 (relop -> LT .)
    ID              reduce using rule 16 (relop -> LT .)
    LPAREN          reduce using rule 16 (relop -> LT .)


state 42

    (17) relop -> GE .

    NUMBER          reduce using rule 17 (relop -> GE .)
    ID              reduce using rule 17 (relop -> GE .)
    LPAREN          reduce using rule 17 (relop -> GE .)


state 43

    (18) relop -> LE .

    NUMBER          reduce using rule 18 (relop -> LE .)
    ID              reduce using rule 18 (relop -> LE .)
    LPAREN          reduce using rule 18 (relop -> LE .)


state 44

    (19) relop -> EQ .

    NUMBER          reduce using rule 19 (relop -> EQ .)
    ID              reduce using rule 19 (relop -> EQ .)
    LPAREN          reduce using rule 19 (relop -> EQ .)


state 45

    (20) relop -> NE .

    NUMBER          reduce using rule 20 (relop -> NE .)
    ID              reduce using rule 20 (relop -> NE .)
    LPAREN          reduce using rule 20 (relop -> NE .)


state 46

    (12) stmt -> WHILE LPAREN cond RPAREN . stmt
    (9) stmt -> . ID ASSIGN expr SEMI
    (10) stmt -> . IF LPAREN cond RPAREN stmt
    (11) stmt -> . IF LPAREN cond RPAREN stmt ELSE stmt
    (12) stmt -> . WHILE LPAREN cond RPAREN stmt
    (13) stmt -> . LBRACE stmt_list RBRACE

    ID              shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 9
    LBRACE          shift and go to state 10

    stmt                           shift and go to state 54

state 47

    (21) expr -> expr PLUS term .
    (24) term -> term . TIMES factor
    (25) term -> term . DIVIDE factor

    SEMI            reduce using rule 21 (expr -> expr PLUS term .)
    PLUS            reduce using rule 21 (expr -> expr PLUS term .)
    MINUS           reduce using rule 21 (expr -> expr PLUS term .)
    GT              reduce using rule 21 (expr -> expr PLUS term .)
    LT              reduce using rule 21 (expr -> expr PLUS term .)
    GE              reduce using rule 21 (expr -> expr PLUS term .)
    LE              reduce using rule 21 (expr -> expr PLUS term .)
    EQ              reduce using rule 21 (expr -> expr PLUS term .)
    NE              reduce using rule 21 (expr -> expr PLUS term .)
    RPAREN          reduce using rule 21 (expr -> expr PLUS term .)
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36


state 48

    (22) expr -> expr MINUS term .
    (24) term -> term . TIMES factor
    (25) term -> term . DIVIDE factor

    SEMI            reduce using rule 22 (expr -> expr MINUS term .)
    PLUS            reduce using rule 22 (expr -> expr MINUS term .)
    MINUS           reduce using rule 22 (expr -> expr MINUS term .)
    GT              reduce using rule 22 (expr -> expr MINUS term .)
    LT              reduce using rule 22 (expr -> expr MINUS term .)
    GE              reduce using rule 22 (expr -> expr MINUS term .)
    LE              reduce using rule 22 (expr -> expr MINUS term .)
    EQ              reduce using rule 22 (expr -> expr MINUS term .)
    NE              reduce using rule 22 (expr -> expr MINUS term .)
    RPAREN          reduce using rule 22 (expr -> expr MINUS term .)
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36


state 49

    (24) term -> term TIMES factor .

    TIMES           reduce using rule 24 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 24 (term -> term TIMES factor .)
    SEMI            reduce using rule 24 (term -> term TIMES factor .)
    PLUS            reduce using rule 24 (term -> term TIMES factor .)
    MINUS           reduce using rule 24 (term -> term TIMES factor .)
    GT              reduce using rule 24 (term -> term TIMES factor .)
    LT              reduce using rule 24 (term -> term TIMES factor .)
    GE              reduce using rule 24 (term -> term TIMES factor .)
    LE              reduce using rule 24 (term -> term TIMES factor .)
    EQ              reduce using rule 24 (term -> term TIMES factor .)
    NE              reduce using rule 24 (term -> term TIMES factor .)
    RPAREN          reduce using rule 24 (term -> term TIMES factor .)


state 50

    (25) term -> term DIVIDE factor .

    TIMES           reduce using rule 25 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 25 (term -> term DIVIDE factor .)
    SEMI            reduce using rule 25 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 25 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 25 (term -> term DIVIDE factor .)
    GT              reduce using rule 25 (term -> term DIVIDE factor .)
    LT              reduce using rule 25 (term -> term DIVIDE factor .)
    GE              reduce using rule 25 (term -> term DIVIDE factor .)
    LE              reduce using rule 25 (term -> term DIVIDE factor .)
    EQ              reduce using rule 25 (term -> term DIVIDE factor .)
    NE              reduce using rule 25 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 25 (term -> term DIVIDE factor .)


state 51

    (29) factor -> LPAREN expr RPAREN .

    TIMES           reduce using rule 29 (factor -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 29 (factor -> LPAREN expr RPAREN .)
    SEMI            reduce using rule 29 (factor -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 29 (factor -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 29 (factor -> LPAREN expr RPAREN .)
    GT              reduce using rule 29 (factor -> LPAREN expr RPAREN .)
    LT              reduce using rule 29 (factor -> LPAREN expr RPAREN .)
    GE              reduce using rule 29 (factor -> LPAREN expr RPAREN .)
    LE              reduce using rule 29 (factor -> LPAREN expr RPAREN .)
    EQ              reduce using rule 29 (factor -> LPAREN expr RPAREN .)
    NE              reduce using rule 29 (factor -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 29 (factor -> LPAREN expr RPAREN .)


state 52

    (10) stmt -> IF LPAREN cond RPAREN stmt .
    (11) stmt -> IF LPAREN cond RPAREN stmt . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    ID              reduce using rule 10 (stmt -> IF LPAREN cond RPAREN stmt .)
    IF              reduce using rule 10 (stmt -> IF LPAREN cond RPAREN stmt .)
    WHILE           reduce using rule 10 (stmt -> IF LPAREN cond RPAREN stmt .)
    LBRACE          reduce using rule 10 (stmt -> IF LPAREN cond RPAREN stmt .)
    $end            reduce using rule 10 (stmt -> IF LPAREN cond RPAREN stmt .)
    RBRACE          reduce using rule 10 (stmt -> IF LPAREN cond RPAREN stmt .)
    ELSE            shift and go to state 55

  ! ELSE            [ reduce using rule 10 (stmt -> IF LPAREN cond RPAREN stmt .) ]


state 53

    (14) cond -> expr relop expr .
    (21) expr -> expr . PLUS term
    (22) expr -> expr . MINUS term

    RPAREN          reduce using rule 14 (cond -> expr relop expr .)
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34


state 54

    (12) stmt -> WHILE LPAREN cond RPAREN stmt .

    ID              reduce using rule 12 (stmt -> WHILE LPAREN cond RPAREN stmt .)
    IF              reduce using rule 12 (stmt -> WHILE LPAREN cond RPAREN stmt .)
    WHILE           reduce using rule 12 (stmt -> WHILE LPAREN cond RPAREN stmt .)
    LBRACE          reduce using rule 12 (stmt -> WHILE LPAREN cond RPAREN stmt .)
    $end            reduce using rule 12 (stmt -> WHILE LPAREN cond RPAREN stmt .)
    RBRACE          reduce using rule 12 (stmt -> WHILE LPAREN cond RPAREN stmt .)
    ELSE            reduce using rule 12 (stmt -> WHILE LPAREN cond RPAREN stmt .)


state 55

    (11) stmt -> IF LPAREN cond RPAREN stmt ELSE . stmt
    (9) stmt -> . ID ASSIGN expr SEMI
    (10) stmt -> . IF LPAREN cond RPAREN stmt
    (11) stmt -> . IF LPAREN cond RPAREN stmt ELSE stmt
    (12) stmt -> . WHILE LPAREN cond RPAREN stmt
    (13) stmt -> . LBRACE stmt_list RBRACE

    ID              shift and go to state 7
    IF              shift and go to state 8
    WHILE           shift and go to state 9
    LBRACE          shift and go to state 10

    stmt                           shift and go to state 56

state 56

    (11) stmt -> IF LPAREN cond RPAREN stmt ELSE stmt .

    ID              reduce using rule 11 (stmt -> IF LPAREN cond RPAREN stmt ELSE stmt .)
    IF              reduce using rule 11 (stmt -> IF LPAREN cond RPAREN stmt ELSE stmt .)
    WHILE           reduce using rule 11 (stmt -> IF LPAREN cond RPAREN stmt ELSE stmt .)
    LBRACE          reduce using rule 11 (stmt -> IF LPAREN cond RPAREN stmt ELSE stmt .)
    $end            reduce using rule 11 (stmt -> IF LPAREN cond RPAREN stmt ELSE stmt .)
    RBRACE          reduce using rule 11 (stmt -> IF LPAREN cond RPAREN stmt ELSE stmt .)
    ELSE            reduce using rule 11 (stmt -> IF LPAREN cond RPAREN stmt ELSE stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 52 resolved as shift
